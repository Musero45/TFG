function rigidHe    = ndSeedHe2rigidScaledHe(ndHe,b,R,Omega,W,btr,label)

% rigidHe    = ndSeedHe2rigidScaledHe(ndHe,b,R,Omega,W,btr,label) provided
% a scaled rigid helicopter, rigidHe, from a non dimensional helicopter ndhe, which is used as
% a seed and global data of the new helicopter, numer of blades b, radius, R, main rotor angular
% velocity, Omega, weight, W and number of blades of the tail rotor, btr.
%
% This function is identical to ndHe2rigidHe developed by Irene Velasco and it is based in the 
% theoretical developments contained in: 
% [1]. Irene Velasco Suárez. Diseño y Análisis Preliminar de un Helicóptero no Tripulado.
% PFC. ETSI Aeronáuticos. UPM. Noviembre 2017.

rho = ndHe.rho;

n   = length(ndHe);
p   = cell(n,1);


% If there is one helicopter structure it should be redefined to a cell
if n == 1
   ndHe = {ndHe};
end


for i=1:n

% Dimensional variables
area  = pi*R^2;
OR    = Omega*R;
Tu    = rho*area*OR.^2;

% Weight coefficient
CW          = W./Tu;
ndinertia   = ndHe{i}.inertia;
inertia     = ndInertia2inertia(ndinertia,R,rho,label);
inertia.W   = CW*Tu;

% DimensionalMainRotor
ndmr         = ndHe{i}.mainRotor;
mainRotor    = ndRotor2rigidRotor(ndmr,b,R,Omega,rho,label);


% DimensionalTailRotor
ndtr            = ndHe{i}.tailRotor;
Omegatr         = ndHe{i}.rAngVel*Omega;
Rtr             = (ndHe{i}.rVel*Omega*R)/Omegatr;
tailRotor       = ndRotor2rigidRotor(ndtr,btr,Rtr,Omegatr,rho,label);
tailRotor.R     = Rtr;
tailRotor.Omega = Omegatr;


% DimensionalFuselage
activef     = ndHe{i}.fuselage.active;
model       = ndHe{i}.fuselage.model;
ndlf        = ndHe{i}.fuselage.ndlf;
ndSp        = ndHe{i}.fuselage.ndSp;
ndSs        = ndHe{i}.fuselage.ndSs;
kf          = ndHe{i}.fuselage.kf;

fuselage   = struct(...
            'class','fuselage',...
               'id',label,...
           'active',activef,...
            'model',model,...
               'lf',ndlf*R,...
               'Sp',ndSp*area,...
               'Ss',ndSs*area,...
               'kf',kf);

           
% nondimensionalVerticalFin
ndVf            = ndHe{i}.verticalFin;
verticalFin     = ndStabilizer2stabilizer(ndVf,R,label);


% nondimensionalLeftHTP
ndLHTP          = ndHe{i}.leftHTP;
leftHTP         = ndStabilizer2stabilizer(ndLHTP,R,label);


% nondimensionalLeftHTP
ndRHTP          = ndHe{i}.rightHTP;
rightHTP        = ndStabilizer2stabilizer(ndRHTP,R,label);


% nondimensionalGeometry
ndGeom          = ndHe{i}.geometry;
geometry        = ndGeometry2geometry(ndGeom,R,label);

% Define the dimensional rigid helicopter


p{i}     = struct(...
           'class','rigidHe',...
              'id',label,....
       'mainRotor',mainRotor,...
       'tailRotor',tailRotor,...
        'fuselage',fuselage,...
     'verticalFin',verticalFin,...
         'leftHTP',leftHTP,...
        'rightHTP',rightHTP,...
        'geometry',geometry,...
    'transmission',ndHe{i}.transmission,...
         'inertia',inertia ...
                 );

end

if n == 1
   rigidHe = p{1};
else 
   rigidHe = p;
end
end



function inertia    = ndInertia2inertia(ndInertia,R,rho,label)
    
num = rho*pi*R^5;

gammax   = ndInertia.gammax;
gammay   = ndInertia.gammay;
gammaz   = ndInertia.gammaz;
RIxy     = ndInertia.RIxy;
RIzy     = ndInertia.RIzy;
RIxyy    = ndInertia.RIxyy;
RIxzy    = ndInertia.RIxzy;
RIyzy    = ndInertia.RIyzy;


Ix  = num/gammax;
Iy  = num/gammay;
Iz  = num/gammaz;
Ixy = RIxyy*Iy;
Ixz = RIxzy*Iy;
Iyz = RIyzy*Iy;


inertia     = struct(...
             'class','inertia',...
                'id',label,...
                 'W',[],...
                'Ix',Ix,...
                'Iy',Iy,...
                'Iz',Iz,...
               'Ixy',Ixy,...
               'Ixz',Ixz,...
               'Iyz',Iyz ...
                   );    
end



function rotor = ndRotor2rigidRotor(ndRotor,b,R,Omega,rho,label)

% Nondimensional rotor data
b0          = ndRotor.b;
sigma0      = ndRotor.sigma0;
sigma1      = ndRotor.sigma1;
cddata      = ndRotor.cddata;
cldata      = ndRotor.cldata;
theta1      = ndRotor.theta1;
ead         = ndRotor.ead;
epsilonR    = ndRotor.epsilonR;
aG          = ndRotor.aG;
Kbeta       = ndRotor.Kbeta;
gamma       = ndRotor.gamma;
RITB        = ndRotor.RITB;
RIZB        = ndRotor.RIZB;
XGB         = ndRotor.XGB;
muP         = ndRotor.muP;
Re          = ndRotor.Re;
M           = ndRotor.M;
k           = ndRotor.k;


% Dimensional rotor

c0         = sigma0*pi*R/b;
c1         = sigma1*pi*R/b;
e          = ead*R;
kBeta      = Kbeta*(rho*pi*R^2*(Omega*R)^2*R);
xGB        = XGB*R;
bm         = muP*(rho*pi*R^3)*(b0/b);
IBeta      = bm*R*xGB/epsilonR;
ITheta     = RITB*IBeta;
IZeta      = RIZB*IBeta;

% Dimensional rotor definition
rotor   = struct(...
         'class','rigidRotor',...
            'id',label,...
        'active',ndRotor.active,...
             'R',R,...
             'e',e,... 
             'b',b,...
        'theta1',theta1,...
        'cldata',cldata,...
        'cddata',cddata,...
       'profile',[],...
         'Omega',Omega,... 
            'c0',c0,... 
            'c1',c1,... 
         'IBeta',IBeta,...
        'ITheta',ITheta,...
         'IZeta',IZeta,...
           'xGB',xGB,...
            'bm',bm,...
         'kBeta',kBeta,... 
             'k',k ...
               );

end

function stabilizer    = ndStabilizer2stabilizer(ndStabilizer,R,label)


% Nondimensional stabilizer data
ndc       = ndStabilizer.ndc;          
ndS       = ndStabilizer.ndS;            

% trim state
active  = ndStabilizer.active;

% Dimensional variables
c = ndc*R;
S = ndS*(pi*R^2);
        
% Dimensional stabilizer definition
stabilizer      = struct(...
                 'class','stabilizer',...
                    'id',label,...
                'active',active,...
               'airfoil',ndStabilizer.airfoil,...@vfBo105Padf,...
                  'type',ndStabilizer.type,...
                     'c',c,...
                     'S',S,...
                 'theta',ndStabilizer.theta,...
                    'ks',ndStabilizer.ks ...
                       );

end

function geometry   = ndGeometry2geometry(ndGeometry,R,label)

% Dimensional geometry definition
geometry = struct(...
          'class','geometry',...
             'id',label,...
            'xcg',ndGeometry.Xcg*R,...
            'ycg',ndGeometry.Ycg*R,...
            'zcg',ndGeometry.Zcg*R,...
       'epsilonx',ndGeometry.epsilonx,...
       'epsilony',ndGeometry.epsilony,...
             'ls',ndGeometry.ndls*R,...
             'ds',ndGeometry.ndds*R,...
              'h',ndGeometry.ndh*R,...
        'thetatr',ndGeometry.thetatr,...
            'ltr',ndGeometry.ndltr*R,...
            'dtr',ndGeometry.nddtr*R,...
            'htr',ndGeometry.ndhtr*R,...
            'lvf',ndGeometry.ndlvf*R,...
            'dvf',ndGeometry.nddvf*R,...
            'hvf',ndGeometry.ndhvf*R,...
        'Gammavf',ndGeometry.Gammavf,...
          'llHTP',ndGeometry.ndllHTP*R,...
          'dlHTP',ndGeometry.nddlHTP*R,...
          'hlHTP',ndGeometry.ndhlHTP*R,...
      'GammalHTP',ndGeometry.GammalHTP,...
          'lrHTP',ndGeometry.ndlrHTP*R,...
          'drHTP',ndGeometry.nddrHTP*R,...
          'hrHTP',ndGeometry.ndhrHTP*R,...
      'GammarHTP',ndGeometry.GammarHTP ...
                ); 
end